#### 十进制转十六进制

将一个十进制数字`x`转换为十六进制，可以反复用`x`除以 16，得到商`q`和余数`r`，即`x=q*16+r`。然后用十六进制数字表示的`r`作为最低位数字，并通过对`q`反复进行这个过程得到剩下的数字。

**例题：** 将十进制 314156 转换十六进制

> 314156 = 19634\*16\+12 **(C)**  
> 19634&ensp; = 1227\*16\+2 **(2)**  
> 1227&emsp;&nbsp; = 76\*16\+11 **(B)**  
> 76&emsp;&emsp;&nbsp; = 4\*16\+12 **(C)**  
> 4&emsp;&emsp;&ensp;&nbsp; = 0\*16\+4 **(4)**

十六进制表示为 0x4cb2c。

## 字数据

我们将程序称为“32 位程序”或者“64 位程序”时，区别在于**该程序是如何编译的，而不是其运行的机器类型。**`linux> gcc -m32 prog.c`该程序可以在 32 位或 64 位机器上正确运行。另一方面，`linux> gcc -m64 prog.c`只能在 64 位机器运行。

#### 基本 C 数据类型的典型大小

| 有符号        | 无符号         | 32 位 | 64 位 |
| ------------- | -------------- | ----- | ----- |
| [signed] char | unsigned char  | 1     | 1     |
| short         | unsigned short | 2     | 2     |
| int           | unsigned       | 4     | 4     |
| long          | unsigned long  | 4     | 8     |
| int32_t       | uint32_t       | 4     | 4     |
| int64_t       | uint64_t       | 8     | 8     |
| char \*       |                | 4     | 8     |
| float         |                | 4     | 4     |
| double        |                | 8     | 8     |

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入来一类数据类型（`int32_t`和`int64_t`），其数据大小是固定的，不随编译器和机器设置而变化。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

#### 大小端

考虑一个`w`位的整数`x`，其位表示为![x](src/ch2/x.svg)，其中![x](src/ch2/x_big.svg)是最高有效位，![x](src/ch2/x_little.svg)是最低有效位。最低有效位所处的字节称为最低有效字节，最高有效位所处的字节称为最高有效字节。

某些机器选择在内存中按照从最高有效字节到最低有效字节的顺序存储对象，称为大端法（big endian），而另一些机器按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）。

**例题：** 假设变量`x`的类型为 int，位于地址 0x100 处，十六进制为 0x01234567。

> ##### 大端法
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | --- | ----- | ----- | ----- | ----- | --- |
> | ... | 01    | 23    | 45    | 67    | ... |
>
> ##### 小端法
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | --- | ----- | ----- | ----- | ----- | --- |
> | ... | 67    | 45    | 23    | 01    | ... |

##### 有些时候，字节顺序可能会成为问题：

1. 在不同类型的机器之间通过网络传输二进制数据时
2. 当阅读表示整数数据的字节序列时
3. 当编写规避正常的类型系统的程序时

##### 使用强制类型转换来规避类型系统，打印程序对象的字节

```C
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (i = 0; i < len; i++)
	printf(" %.2x", start[i]);    //line:data:show_bytes_printf
    printf("\n");
}
```

## C 语言运算

### 位级运算

### 逻辑运算

> P40 顶段话

### 位移运算
