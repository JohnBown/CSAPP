### 十进制转十六进制

将一个十进制数字`x`转换为十六进制，可以反复用`x`除以 16，得到商`q`和余数`r`，即`x=q*16+r`。然后用十六进制数字表示的`r`作为最低位数字，并通过对`q`反复进行这个过程得到剩下的数字。

**例题** 将十进制 314156 转换十六进制

> 314156 = 19634\*16\+12 **(C)**  
> 19634&ensp; = 1227\*16\+2 **(2)**  
> 1227&emsp;&nbsp; = 76\*16\+11 **(B)**  
> 76&emsp;&emsp;&nbsp; = 4\*16\+12 **(C)**  
> 4&emsp;&emsp;&ensp;&nbsp; = 0\*16\+4 **(4)**

十六进制表示为 0x4cb2c。

## 字数据

我们将程序称为“32 位程序”或者“64 位程序”时，区别在于**该程序是如何编译的，而不是其运行的机器类型。**`linux> gcc -m32 prog.c`该程序可以在 32 位或 64 位机器上正确运行。另一方面，`linux> gcc -m64 prog.c`只能在 64 位机器运行。

### 基本 C 数据类型的典型大小

| 有符号        | 无符号         | 32 位 | 64 位 |
| ------------- | -------------- | :---: | :---: |
| [signed] char | unsigned char  |   1   |   1   |
| short         | unsigned short |   2   |   2   |
| int           | unsigned       |   4   |   4   |
| long          | unsigned long  |   4   |   8   |
| int32_t       | uint32_t       |   4   |   4   |
| int64_t       | uint64_t       |   8   |   8   |
| char \*       |                |   4   |   8   |
| float         |                |   4   |   4   |
| double        |                |   8   |   8   |

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入来一类数据类型（`int32_t`和`int64_t`），其数据大小是固定的，不随编译器和机器设置而变化。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

### 大小端

考虑一个`w`位的整数`x`，其位表示为![x](src/ch2/x.svg)，其中![x](src/ch2/x_big.svg)是最高有效位，![x](src/ch2/x_little.svg)是最低有效位。最低有效位所处的字节称为最低有效字节，最高有效位所处的字节称为最高有效字节。

某些机器选择在内存中按照从最高有效字节到最低有效字节的顺序存储对象，称为大端法（big endian），而另一些机器按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）。

**例题** 假设变量`x`的类型为 int，位于地址 0x100 处，十六进制为 0x01234567。

> **大端法**
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | :-: | :---: | :---: | :---: | :---: | :-: |
> | ... |  01   |  23   |  45   |  67   | ... |
>
> **小端法**
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | :-: | :---: | :---: | :---: | :---: | :-: |
> | ... |  67   |  45   |  23   |  01   | ... |

**需要重视字节顺序的情形：**

1. 在不同类型的机器之间通过网络传输二进制数据时
2. 当阅读表示整数数据的字节序列时
3. 当编写规避正常的类型系统的程序时

```C
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (i = 0; i < len; i++)
	printf(" %.2x", start[i]);    //line:data:show_bytes_printf
    printf("\n");
}
```

_[code. 使用强制类型转换来规避类型系统，打印程序对象的字节]_

## C 语言运算

### 位级运算

C 语言支持按位布尔运算。

- 与 And：`A=1` 且 `B=1` 时，`A&B=1`
- 或 Or：`A=1` 或 `B=1` 时，`A|B=1`
- 非 Not：`A=1` 时，`~A=0`；`A=0` 时，`~A=1`
- 异或 Exclusive-Or(Xor)：`A!=B` 时，`A^B=1`；`A=B` 时，`A^B=0`

位级运算常见用法就是实现**掩码**运算。

**练习题 2.12** 对于下面的值，写出变量`x`的 C 语言表达式。你的代码应该对任何字长`w>=8`都能工作。给出`x=0x87654321`以及`w=32`时表达式的求值结果，以供参考。

- `x`的最低有效字节，其他位均置为 0。_[0x00000021]_
- 除了`x`的最低有效字节外， 其他的位都取补，最低有效字节保持不变。_[0x789ABC21]_
- `x`的最低有效字节设置成全 1，其他字节都保持不变。_[0x876543EF]_

> - x&0xFF
> - x^~0xFF
> - x|0xFF
>
> `～0xFF`低 8 位为 0,其余位为 1，掩码的产生与字长无关。而表达式`0xFFFFFF00`只能工作在 32 位机器上。

### 逻辑运算

C 语言提供了一组逻辑运算`||`、`&&`和`!`，分别对应命题逻辑的`OR`、`AND`和`NOT`运算。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

**位级运算和逻辑运算的重要区别：** 如果第一个参数求值就能确定表达式的结果，逻辑运算符就不会对第二参数求值。

> - a&&5/a 不会造成被除零
> - p&&\*p++ 不会导致间接引用空指针

**练习题 2.14** 只使用位级运算和逻辑运算，编写一个 C 表达式，它等价于`x==y`。当`x`和`y`相等时它返回 1，否则返回 0。

> !(x^y)

### 位移运算

**左移** 对于一个位表示为![x](src/ch2/x.svg)对操作数`x`，C 表达式`x<<k`会生成为![x_leftshift](src/ch2/x_leftshift.svg)。`x`向左移动`k`位，丢弃最高`k`位，并在右端补`k`个 0。位移量`k`应该是一个`0~w-1`之间的值，当超过这个范围，会用`k mod w`得到的新值来算。

**逻辑/算术右移** 右移的运算模式基本和左移相对称，但区别在于逻辑右移向左端补 0，算术右移向左端补符号位的值。基本上，编译器规定对有符号数使用算术右移，对无符号数使用逻辑右移。

## 整型

### 编码

假设数据类型有`w`位，可将其写做向量的形式，记向量 ![vec_x](src/ch2/vec_x.svg)，在不同编码中，每个位取值 0 或 1。

|      无符号数编码       | 补码（Two's Complement） |
| :---------------------: | :----------------------: |
| ![B2U](src/ch2/B2U.svg) | ![B2T](src/ch2/B2T.svg)  |

<table>
    <tr align="center">
        <th rowspan="2">数</td>
        <th colspan="4">字长w</td>
    </tr>
    <tr align="center">
        <td>8</td>
        <td>16</td>
        <td>32</td>
        <td>64</td>
    </tr>
    <tr>
        <td>UMax</td>
        <td>0xFF<br>255</td>
        <td>0xFFFF<br>65,535</td>
        <td>0xFFFF FFFF<br>4,294,967,295</td>
        <td>0xFFFF FFFF FFFF FFFF<br>18,446,744,073,709,551,615</td>
    </tr>
    <tr>
        <td>TMin</td>
        <td>0x80<br>-128</td>
        <td>0x8000<br>-32,768</td>
        <td>0x8000 0000<br>-2,147,483,648</td>
        <td>0x8000 0000 0000 0000<br>-9,223,372,036,854,775,808</td>
    </tr>
    <tr>
        <td>TMax</td>
        <td>0x7F<br>127</td>
        <td>0x7FFF<br>32,767</td>
        <td>0x7FFF FFFF<br>2,147,483,647</td>
        <td>0x7FFF FFFF FFFF FFFF<br>9,223,372,036,854,775,807</td>
    </tr>
    <tr>
        <td>-1<br>0</td>
        <td>0xFF<br>0x00</td>
        <td>0xFFFF<br>0x0000</td>
        <td>0xFFFF FFFF<br>0x0000 0000</td>
        <td>0xFFFF FFFF FFFF FFFF<br>0x0000 0000 0000 0000</td>
    </tr>

</table>

> **Tips**
>
> - `UMin=0`即`000...0`
> - `UMax=2ʷ-1`即`111...1`
> - `TMin=-2ʷ⁻¹`即`100...0`
> - `TMax=2ʷ⁻¹-1`即`011...1`
> - `-1`即`111...1`

自然可得：`|TMin| = |TMax| + 1`以及`|UMax| = 2|Max| + 1`

前面已经见识过 32 位和 64 位版本确定大小的整数类型（`int32_t`和`int64_t`），事实上 ISO C99 标准在文件 stdint.h 中定义了一组数据类型，它们声明形如`intN_t`和`uintN_t`，不同`N`值指定不同的`N`位。这些数据都对应一组宏，定义了每个`N`都值对应的最大和最小值，形如`INTN_MIN`、`INTN_MAX`和`UINTN_MAX`。

#### 有符号数其他表示

| 反码（Ones' Complement） | 原码（Sign-Magnitude）  |
| :----------------------: | :---------------------: |
| ![B2O](src/ch2/B2O.svg)  | ![B2S](src/ch2/B2S.svg) |

> **推导** 考虑反码表示 0 的情况  
> ![proof_1/eq1_1](src/ch2/pof_1/eq1_1.svg)  
> **a)** 当 ![aa](src/ch2/pof_1/x.svg) 等于 0：  
> ![proof_1/eq1_2](src/ch2/pof_1/eq1_2.svg)  
> **b)** 当 ![aa](src/ch2/pof_1/x.svg) 等于 1：  
> ![proof_1/eq1_3](src/ch2/pof_1/eq1_3.svg)

所以，利用反码对 0 进行编码具有两种不同的形式（`[0,0,0,...,0]`和`[1,1,1,...,1]`）。同理不难推出，利用原码对 0 进行编码，也具有两种不同对形式（`0,0,0,...,0`和`1,0,0,...,0`），这也是体现补码优越的地方。

### 转换

对于大多数 C 语言的实现，处理**同样字长**的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变。

```C
short int v = -12345;
unsigned short uv = (unsigned short) v;

> v = -12345, uv = 53191
```

```C
unsigned u = 4294967295u;
int tu = (int) u;

> u = 4294967295, tu = -1
```

|           补码转换为无符号数            |           无符号数转换为补码            |
| :-------------------------------------: | :-------------------------------------: |
| ![TMin_x_TMax](src/ch2/TMin_x_TMax.svg) | ![zero_u_Umax](src/ch2/zero_u_UMax.svg) |
|         ![T2U](src/ch2/T2U.svg)         |         ![U2T](src/ch2/U2T.svg)         |
|         ![t2u](src/ch2/t2u.svg)         |         ![u2t](src/ch2/u2t.svg)         |

> **推导**  
> ![proof_2/eq2_1](src/ch2/pof_2/eq2_1.svg)  
> **a)** 补码转换无符号数  
> ![proof_2/eq2_2](src/ch2/pof_2/eq2_2.svg)  
> **b)** 无符号数转换补码  
> 设 ![proof_2/eq2_3](src/ch2/pof_2/eq2_3.svg)  
> ![proof_2/eq2_4](src/ch2/pof_2/eq2_4.svg)

#### 转换发生情况

**情况一** 显示强制类型转换

```C
int tx, ty;
unsigned ux, uy;

tx = (int) ux;
uy = (unsigned) ty;
```

**情况二** 隐式转换

```C
int tx, ty;
unsigned ux, uy;

tx = ux; /* Cast to signed */
uy = ty; /* Cast to unsigned */
```

**情况三** print 格式化输出转换

```C
int x = -1;
unsigned u = 2147483648;

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

> x = 4294967295 = -1  
> u = 2147483648 = -2147483648

当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

|            表达式             |  类型  | 求值 |
| :---------------------------: | :----: | :--: |
|            0 == 0U            | 无符号 |  1   |
|            -1 < 0             | 有符号 |  1   |
|            -1 < 0U            | 无符号 | 0\*  |
|  2147483647 > -2147483647-1   | 有符号 |  1   |
|  2147483647U > -2147483647-1  | 无符号 | 0\*  |
| 2147483647 > (int)2147483648U | 有符号 | 1\*  |
|            -1 > -2            | 有符号 |  1   |
|        (unsigned)-1>-2        | 无符号 |  1   |

**练习题 2.21** 假设在采用补码运算的 32 位机器上对表达式求值

|            表达式            |  类型  | 求值 |
| :--------------------------: | :----: | :--: |
| -2147483647-1 == 2147483648U | 无符号 |  1   |
|  -2147483647-1 < 2147483647  | 有符号 |  1   |
| -2147483647-1U < 2147483647  | 无符号 |  0   |
| -2147483647-1 < -2147483647  | 有符号 |  1   |
| -2147483647-1U < -2147483647 | 无符号 |  1   |

> **技巧** `2147483647 == [0,1,1,...,1]`  
> `-2147483647-1 == 2147483648 == [1,0,0,..,0]`  
> `-2147483647 == [1,0,...,0,1]`

```C
#include<limits.h>

#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```

### 扩展与截断

**扩展**

无符号数的零扩展（Zero Extension）：  
![zero_extension](src/ch2/zero_ext.svg)

补码数的符号扩展（Sign Extension）：  
![sign_extension](src/ch2/sign_ext.svg)

```C
short sx = -12345;
unsigned short usx = sx;
int x = sx;
unsigned ux = usx;

> sx = -12345: cf c7
> usx = 53191: cf c7
> x = -12345: ff ff cf c7
> ux = 53191: 00 00 cf c7
```

> 推导  
> ![proof_3/eq3_1](src/ch2/pof_3/eq3_1.svg)  
> 较为简单，略

C 语言标准要求，把`short`转换成`unsigned`，要**先改变大小，再从有符号到无符号**进行转换。也就是说`(unsigned) sx`等价于`(unsigned) (int) sx`。而非`(unsigned) (unsigned short) sx`。

```C
short sx = -12345;
unsigned uy = sx;

> uy = 4294954951:  ff ff cf c7 ✔
> uy = 53191:       00 00 cf c7 ✘
```

**练习题 2.23** 根据 C 函数填表

```C
int fun1(unsigned word){
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word){
    return ((int) word << 24) >> 24;
}
```

> |     w      |  fun1(w)   |  fun2(w)   |
> | :--------: | :--------: | :--------: |
> | 0x00000076 | 0x00000076 | 0x00000076 |
> | 0x87654321 | 0x00000021 | 0x00000021 |
> | 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
> | 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |
>
> **思路** `fun1()`位移是在无符号数上进行的，所以执行的是逻辑右移，`fun2()`位移是在带符号数上进行的，所以执行的是算术右移。两函数都是从低 8 位提取数，但区别是`fun2()`还要进行符号位扩展。

**截断**

无符号数的截断：  
![unsigned_truncating](src/ch2/u_trunc.svg)

补码数字的截断：  
![signed_truncating](src/ch2/t_trunc.svg)

```C
int x = 53191;
short sx = (short) x;   /* -12345 */
int y = sx;             /* -12345 */

> x = 53191; 00 00 cf c7
> sx = -12345; cf c7
> y = -12345; ff ff cf c7
```

> **推导**  
> ![eq4_1.svg](src/ch2/pof_4/eq4_1.svg)

## 整数运算

### 整数加法运算

|                                 | 无符号加法                                           | 补码加法                                                                                                                                                           |
| :-----------------------------: | :--------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|        对满足的`x`和`y`         | `0 ≦ x,y ≦ 2ʷ - 1`                                   | `-2ʷ⁻¹ ≦ x,y ≦ 2ʷ⁻¹-1`                                                                                                                                             |
|              公式               | ![unsigned_addition](src/ch2/uadd.svg)               | ![signed_addition](src/ch2/tadd.svg)                                                                                                                               |
|             关系图              | ![uadd_ovf](src/ch2/uadd_ovf.svg)                    | ![tadd_ovf](src/ch2/tadd_ovf.svg)                                                                                                                                  |
| 加法溢出检测，<br>令`s = x+y`。 | 当且仅当`s < x`（或者等价地`s < y`）时，发生了溢出。 | 当且仅当`x > 0, y > 0`，但`s ≦ 0`时，计算`s`发生了正溢出（positive overflow）。<br>当且仅当`x < 0, y < 0`，但`s ≧ 0`时，计算`s`发生了负溢出（negative overflow）。 |

**练习题 2.27** 写出具有如下原型的函数：

```C
int uadd_ok(unsigned x, unsigned y);
```

> 如果参数`x`和`y`相加不会产生溢出，这个函数就返回 1。
>
> ```C
> unsigned sum = x + y;
> return sum >= x;
> ```

#### 无符号数求反

对满足`0 ≦ x < 2ʷ`的任意`x`，其无符号加法**逆元**：  
![unsigned_add_inverse_element](src/ch2/uadd_inv.svg)

> **推导** 补码加法  
> ![proof_5/eq5_1](src/ch2/pof_5/eq5_1.svg)  
> 定义`z = x + y`，`z' = z mod 2^w`，`z'' = U2T(z')`。分四种情况进行讨论：
>
> 1. 当`-2ʷ ≦ z < -2ʷ⁻¹`时，`0 ≦ z' = z + 2ʷ < 2ʷ⁻¹`，`z'' = z' = x + y + 2ʷ`。_(负溢出)_
> 2. 当`-2ʷ⁻¹ ≦ z < 0`时，`2ʷ⁻¹ ≦ z' = z + 2ʷ < 2ʷ`，`z'' = z' - 2ʷ = x + y`。
> 3. 当`0 ≦ z < 2ʷ⁻¹`时，`0 ≦ z' = z < 2ʷ⁻¹`，`z'' = z = x + y`。
> 4. 当`2ʷ⁻¹ ≦ z < 2ʷ`时，`2ʷ⁻¹ ≦ z' = z < 2ʷ`，`z'' = z' - 2ʷ = x + y - 2ʷ`。_（正溢出）_
>
> 为啥`z'' = z' - 2ʷ`而不是`-2ʷ⁻¹`，因为`w-1`位权为 1 时，补码和无符号相差 2 个`2ʷ⁻¹`也就是`2ʷ`。

**练习题 2.30** 写出具有如下原型的函数：

```C
int tadd_ok(int x, int y);
```

> 如果参数`x`和`y`相加不会产生溢出，这个函数就返回 1。
>
> ```C
> int sum = x + y;
> int neg_ovf = x < 0 && y < 0 && sum >= 0;   //TODO: 边界0
> int pos_ovf = x >= 0 && y >= 0 && sum < 0;
> return !neg_ovf && !pos_ovf;
> ```

**练习题 2.32** 分析`tsub_ok()`代码，`x`和`y`取什么值时，会产生错误结果。

```C
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
```

> 考虑`x - y`，当`y = TMin`时，`tadd_ok(x, -y) -> tadd_ok(x, y)`，`y < 0`，所以当`x < 0`，发生负溢出。  
> 实际上`x - TMin == x + |TMin|`，`|TMin| > 0`，所以当`x > 0`时，发生正溢出，结果恰恰相反。

#### 补码的非

对满足`TMin ≦ x ≦ TMax`的`x`，其补码非：  
![signed_add_inverse_element](src/ch2/tadd_inv.svg)

> **推导** `TMin + TMin = -2ʷ⁻¹ + (-2ʷ⁻¹) = -2ʷ`，这将导致负溢出，因此`TMin + TMin = -2ʷ + 2ʷ = 0`是自己的加法逆元。

**补码非位级算法**

**方法一** 对每一位求补，再对结果加 1。在 C 语言中，对任意整数值`x`，计算表达式`-x`和`~x+1`得到对结果完全一样。

|       x        |       ~x       |    incr(~x)    |
| :------------: | :------------: | :------------: |
| [0101]&emsp;5  | [1010]&emsp;-6 | [1011]&emsp;-5 |
| [0111]&emsp;7  | [1000]&emsp;-8 | [1001]&emsp;-7 |
| [1100]&emsp;-4 | [0011]&emsp;3  | [0100]&emsp;4  |
| [0000]&emsp;0  | [1111]&emsp;-1 | [0000]&emsp;0  |
| [1000]&emsp;8  | [0111]&emsp;7  | [1000]&emsp;-8 |

**方法二** 假设`k`是最右边对 1 的位置，对`k`左边对所有位取反。

|       x        |       -x       |
| :------------: | :------------: |
| [1100]&emsp;-4 | [0100]&emsp;4  |
| [1000]&emsp;-8 | [1000]&emsp;-8 |
| [0101]&emsp;5  | [1011]&emsp;-5 |
| [0111]&emsp;7  | [1001]&emsp;-7 |

### 整数乘法运算

|                  |                  无符号乘法                  |                  补码乘法                  |
| :--------------: | :------------------------------------------: | :----------------------------------------: |
| 对满足的`x`和`y` |              `0 ≦ x,y ≦ 2ʷ - 1`              |           `-2ʷ⁻¹ ≦ x,y ≦ 2ʷ⁻¹-1`           |
|       下界       |                     `0`                      |     `(-2ʷ⁻¹)×(2ʷ⁻¹-1) = -2²ʷ⁻² + 2ʷ⁻¹`     |
|       上界       |       `(2ʷ - 1)×(2ʷ - 1) = 2²ʷ-2ʷ⁺¹+1`       |         `(-2ʷ⁻¹)×(-2ʷ⁻¹) = 2²ʷ⁻²`          |
|     取值范围     |            `0 ≦ x×y ≦ 2²ʷ-2ʷ⁺¹+1`            |       `-2²ʷ⁻² + 2ʷ⁻¹ ≦ x×y ≦ 2²ʷ⁻²`        |
|       公式       | ![unsigned_multiplication](src/ch2/umul.svg) | ![signed_multiplication](src/ch2/tmul.svg) |
