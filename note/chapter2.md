### 十进制转十六进制

将一个十进制数字`x`转换为十六进制，可以反复用`x`除以 16，得到商`q`和余数`r`，即`x=q*16+r`。然后用十六进制数字表示的`r`作为最低位数字，并通过对`q`反复进行这个过程得到剩下的数字。

**例题** 将十进制 314156 转换十六进制

> 314156 = 19634\*16\+12 **(C)**  
> 19634&ensp; = 1227\*16\+2 **(2)**  
> 1227&emsp;&nbsp; = 76\*16\+11 **(B)**  
> 76&emsp;&emsp;&nbsp; = 4\*16\+12 **(C)**  
> 4&emsp;&emsp;&ensp;&nbsp; = 0\*16\+4 **(4)**

十六进制表示为 0x4cb2c。

## 字数据

我们将程序称为“32 位程序”或者“64 位程序”时，区别在于**该程序是如何编译的，而不是其运行的机器类型。**`linux> gcc -m32 prog.c`该程序可以在 32 位或 64 位机器上正确运行。另一方面，`linux> gcc -m64 prog.c`只能在 64 位机器运行。

### 基本 C 数据类型的典型大小

| 有符号        | 无符号         | 32 位 | 64 位 |
| ------------- | -------------- | :---: | :---: |
| [signed] char | unsigned char  |   1   |   1   |
| short         | unsigned short |   2   |   2   |
| int           | unsigned       |   4   |   4   |
| long          | unsigned long  |   4   |   8   |
| int32_t       | uint32_t       |   4   |   4   |
| int64_t       | uint64_t       |   8   |   8   |
| char \*       |                |   4   |   8   |
| float         |                |   4   |   4   |
| double        |                |   8   |   8   |

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入来一类数据类型（`int32_t`和`int64_t`），其数据大小是固定的，不随编译器和机器设置而变化。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

### 大小端

考虑一个`w`位的整数`x`，其位表示为![x](src/ch2/x.svg)，其中![x](src/ch2/x_big.svg)是最高有效位，![x](src/ch2/x_little.svg)是最低有效位。最低有效位所处的字节称为最低有效字节，最高有效位所处的字节称为最高有效字节。

某些机器选择在内存中按照从最高有效字节到最低有效字节的顺序存储对象，称为大端法（big endian），而另一些机器按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法（little endian）。

**例题** 假设变量`x`的类型为 int，位于地址 0x100 处，十六进制为 0x01234567。

> **大端法**
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | :-: | :---: | :---: | :---: | :---: | :-: |
> | ... |  01   |  23   |  45   |  67   | ... |
>
> **小端法**
>
> |     | 0x100 | 0x101 | 0x102 | 0x103 |     |
> | :-: | :---: | :---: | :---: | :---: | :-: |
> | ... |  67   |  45   |  23   |  01   | ... |

**需要重视字节顺序的情形：**

1. 在不同类型的机器之间通过网络传输二进制数据时
2. 当阅读表示整数数据的字节序列时
3. 当编写规避正常的类型系统的程序时

```C
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (i = 0; i < len; i++)
	printf(" %.2x", start[i]);    //line:data:show_bytes_printf
    printf("\n");
}
```

_[code. 使用强制类型转换来规避类型系统，打印程序对象的字节]_

## C 语言运算

### 位级运算

C 语言支持按位布尔运算。

- 与 And：`A=1` 且 `B=1` 时，`A&B=1`
- 或 Or：`A=1` 或 `B=1` 时，`A|B=1`
- 非 Not：`A=1` 时，`~A=0`；`A=0` 时，`~A=1`
- 异或 Exclusive-Or(Xor)：`A!=B` 时，`A^B=1`；`A=B` 时，`A^B=0`

位级运算常见用法就是实现**掩码**运算。

**练习题 2.12** 对于下面的值，写出变量`x`的 C 语言表达式。你的代码应该对任何字长`w>=8`都能工作。给出`x=0x87654321`以及`w=32`时表达式的求值结果，以供参考。

- `x`的最低有效字节，其他位均置为 0。_[0x00000021]_
- 除了`x`的最低有效字节外， 其他的位都取补，最低有效字节保持不变。_[0x789ABC21]_
- `x`的最低有效字节设置成全 1，其他字节都保持不变。_[0x876543EF]_

> - x&0xFF
> - x^~0xFF
> - x|0xFF
>
> `～0xFF`低 8 位为 0,其余位为 1，掩码的产生与字长无关。而表达式`0xFFFFFF00`只能工作在 32 位机器上。

### 逻辑运算

C 语言提供了一组逻辑运算`||`、`&&`和`!`，分别对应命题逻辑的`OR`、`AND`和`NOT`运算。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

**位级运算和逻辑运算的重要区别：** 如果第一个参数求值就能确定表达式的结果，逻辑运算符就不会对第二参数求值。

> - a&&5/a 不会造成被除零
> - p&&\*p++ 不会导致间接引用空指针

**练习题 2.14** 只使用位级运算和逻辑运算，编写一个 C 表达式，它等价于`x==y`。当`x`和`y`相等时它返回 1，否则返回 0。

> !(x^y)

### 位移运算

**左移** 对于一个位表示为![x](src/ch2/x.svg)对操作数`x`，C 表达式`x<<k`会生成为![x_leftshift](src/ch2/x_leftshift.svg)。`x`向左移动`k`位，丢弃最高`k`位，并在右端补`k`个 0。位移量`k`应该是一个`0~w-1`之间的值，当超过这个范围，会用`k mod w`得到的新值来算。

**逻辑/算术右移** 右移的运算模式基本和左移相对称，但区别在于逻辑右移向左端补 0，算术右移向左端补符号位的值。基本上，编译器规定对有符号数使用算术右移，对无符号数使用逻辑右移。

## 整型

### 编码

假设数据类型有`w`位，可将其写做向量的形式，记向量 ![vec_x](src/ch2/vec_x.svg)，在不同编码中，每个位取值 0 或 1。

|      无符号数编码       | 补码（Two's Complement） |
| :---------------------: | :----------------------: |
| ![B2U](src/ch2/B2U.svg) | ![B2T](src/ch2/B2T.svg)  |

<table>
    <tr align="center">
        <th rowspan="2">数</td>
        <th colspan="4">字长w</td>
    </tr>
    <tr align="center">
        <td>8</td>
        <td>16</td>
        <td>32</td>
        <td>64</td>
    </tr>
    <tr>
        <td>UMax</td>
        <td>0xFF<br>255</td>
        <td>0xFFFF<br>65,535</td>
        <td>0xFFFF FFFF<br>4,294,967,295</td>
        <td>0xFFFF FFFF FFFF FFFF<br>18,446,744,073,709,551,615</td>
    </tr>
    <tr>
        <td>TMin</td>
        <td>0x80<br>-128</td>
        <td>0x8000<br>-32,768</td>
        <td>0x8000 0000<br>-2,147,483,648</td>
        <td>0x8000 0000 0000 0000<br>-9,223,372,036,854,775,808</td>
    </tr>
    <tr>
        <td>TMax</td>
        <td>0x7F<br>127</td>
        <td>0x7FFF<br>32,767</td>
        <td>0x7FFF FFFF<br>2,147,483,647</td>
        <td>0x7FFF FFFF FFFF FFFF<br>9,223,372,036,854,775,807</td>
    </tr>
    <tr>
        <td>-1<br>0</td>
        <td>0xFF<br>0x00</td>
        <td>0xFFFF<br>0x0000</td>
        <td>0xFFFF FFFF<br>0x0000 0000</td>
        <td>0xFFFF FFFF FFFF FFFF<br>0x0000 0000 0000 0000</td>
    </tr>

</table>

> **Tips**
>
> - `UMin=0`即`000...0`
> - `UMax=2ʷ-1`即`111...1`
> - `TMin=-2ʷ⁻¹`即`100...0`
> - `TMax=2ʷ⁻¹-1`即`011...1`
> - `-1`即`111...1`

自然可得：`|TMin| = |TMax| + 1`以及`|UMax| = 2|Max| + 1`

前面已经见识过 32 位和 64 位版本确定大小的整数类型（`int32_t`和`int64_t`），事实上 ISO C99 标准在文件 stdint.h 中定义了一组数据类型，它们声明形如`intN_t`和`uintN_t`，不同`N`值指定不同的`N`位。这些数据都对应一组宏，定义了每个`N`都值对应的最大和最小值，形如`INTN_MIN`、`INTN_MAX`和`UINTN_MAX`。

#### 有符号数其他表示

| 反码（Ones' Complement） | 原码（Sign-Magnitude）  |
| :----------------------: | :---------------------: |
| ![B2O](src/ch2/B2O.svg)  | ![B2S](src/ch2/B2S.svg) |

> **推导** 考虑反码表示 0 的情况  
> ![proof_1/eq1_1](src/ch2/pof_1/eq1_1.svg)  
> **a)** 当 ![aa](src/ch2/pof_1/x.svg) 等于 0：  
> ![proof_1/eq1_2](src/ch2/pof_1/eq1_2.svg)  
> **b)** 当 ![aa](src/ch2/pof_1/x.svg) 等于 1：  
> ![proof_1/eq1_3](src/ch2/pof_1/eq1_3.svg)

所以，利用反码对 0 进行编码具有两种不同的形式（`[0,0,0,...,0]`和`[1,1,1,...,1]`）。同理不难推出，利用原码对 0 进行编码，也具有两种不同对形式（`0,0,0,...,0`和`1,0,0,...,0`），这也是体现补码优越的地方。

### 转换

对于大多数 C 语言的实现，处理**同样字长**的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变。

```C
short int v = -12345;
unsigned short uv = (unsigned short) v;

> v = -12345, uv = 53191
```

```C
unsigned u = 4294967295u;
int tu = (int) u;

> u = 4294967295, tu = -1
```

|           补码转换为无符号数            |           无符号数转换为补码            |
| :-------------------------------------: | :-------------------------------------: |
| ![TMin_x_TMax](src/ch2/TMin_x_TMax.svg) | ![zero_u_Umax](src/ch2/zero_u_UMax.svg) |
|         ![T2U](src/ch2/T2U.svg)         |         ![U2T](src/ch2/U2T.svg)         |
|         ![t2u](src/ch2/t2u.svg)         |         ![u2t](src/ch2/u2t.svg)         |

> **推导**  
> ![proof_2/eq2_1](src/ch2/pof_2/eq2_1.svg)  
> **a)** 补码转换无符号数  
> ![proof_2/eq2_2](src/ch2/pof_2/eq2_2.svg)  
> **b)** 无符号数转换补码  
> 设 ![proof_2/eq2_3](src/ch2/pof_2/eq2_3.svg)  
> ![proof_2/eq2_4](src/ch2/pof_2/eq2_4.svg)

#### 转换发生情况

**情况一** 显示强制类型转换

```C
int tx, ty;
unsigned ux, uy;

tx = (int) ux;
uy = (unsigned) ty;
```

**情况二** 隐式转换

```C
int tx, ty;
unsigned ux, uy;

tx = ux; /* Cast to signed */
uy = ty; /* Cast to unsigned */
```

**情况三** print 格式化输出转换

```C
int x = -1;
unsigned u = 2147483648;

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

> x = 4294967295 = -1  
> u = 2147483648 = -2147483648

当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

|            表达式             |  类型  | 求值 |
| :---------------------------: | :----: | :--: |
|            0 == 0U            | 无符号 |  1   |
|            -1 < 0             | 有符号 |  1   |
|            -1 < 0U            | 无符号 | 0\*  |
|  2147483647 > -2147483647-1   | 有符号 |  1   |
|  2147483647U > -2147483647-1  | 无符号 | 0\*  |
| 2147483647 > (int)2147483648U | 有符号 | 1\*  |
|            -1 > -2            | 有符号 |  1   |
|        (unsigned)-1>-2        | 无符号 |  1   |

**练习题 2.21** 假设在采用补码运算的 32 位机器上对表达式求值

|            表达式            |  类型  | 求值 |
| :--------------------------: | :----: | :--: |
| -2147483647-1 == 2147483648U | 无符号 |  1   |
|  -2147483647-1 < 2147483647  | 有符号 |  1   |
| -2147483647-1U < 2147483647  | 无符号 |  0   |
| -2147483647-1 < -2147483647  | 有符号 |  1   |
| -2147483647-1U < -2147483647 | 无符号 |  1   |

> **技巧** `2147483647 == [0,1,1,...,1]`  
> `-2147483647-1 == 2147483648 == [1,0,0,..,0]`  
> `-2147483647 == [1,0,...,0,1]`

```C
#include<limits.h>

#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```

### 扩展与截断

**扩展**

无符号数的零扩展（Zero Extension）：  
![zero_extension](src/ch2/zero_ext.svg)

补码数的符号扩展（Sign Extension）：  
![sign_extension](src/ch2/sign_ext.svg)

```C
short sx = -12345;
unsigned short usx = sx;
int x = sx;
unsigned ux = usx;

> sx = -12345: cf c7
> usx = 53191: cf c7
> x = -12345: ff ff cf c7
> ux = 53191: 00 00 cf c7
```

> 推导  
> ![proof_3/eq3_1](src/ch2/pof_3/eq3_1.svg)  
> 较为简单，略

C 语言标准要求，把`short`转换成`unsigned`，要**先改变大小，再从有符号到无符号**进行转换。也就是说`(unsigned) sx`等价于`(unsigned) (int) sx`。而非`(unsigned) (unsigned short) sx`。

```C
short sx = -12345;
unsigned uy = sx;

> uy = 4294954951:  ff ff cf c7 ✔
> uy = 53191:       00 00 cf c7 ✘
```

**练习题 2.23** 根据 C 函数填表

```C
int fun1(unsigned word){
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word){
    return ((int) word << 24) >> 24;
}
```

> |     w      |  fun1(w)   |  fun2(w)   |
> | :--------: | :--------: | :--------: |
> | 0x00000076 | 0x00000076 | 0x00000076 |
> | 0x87654321 | 0x00000021 | 0x00000021 |
> | 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
> | 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |
>
> **思路** `fun1()`位移是在无符号数上进行的，所以执行的是逻辑右移，`fun2()`位移是在带符号数上进行的，所以执行的是算术右移。两函数都是从低 8 位提取数，但区别是`fun2()`还要进行符号位扩展。

**截断**

无符号数的截断：  
![unsigned_truncating](src/ch2/u_trunc.svg)

补码数字的截断：  
![signed_truncating](src/ch2/t_trunc.svg)

```C
int x = 53191;
short sx = (short) x;   /* -12345 */
int y = sx;             /* -12345 */

> x = 53191; 00 00 cf c7
> sx = -12345; cf c7
> y = -12345; ff ff cf c7
```

> **推导**  
> ![eq4_1.svg](src/ch2/pof_4/eq4_1.svg)

## 整数运算

### 整数加法运算

|                                 | 无符号加法                                           | 补码加法                                                                                                                                                           |
| :-----------------------------: | :--------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|        对满足的`x`和`y`         | `0 ≦ x,y ≦ 2ʷ - 1`                                   | `-2ʷ⁻¹ ≦ x,y ≦ 2ʷ⁻¹-1`                                                                                                                                             |
|              公式               | ![unsigned_addition](src/ch2/uadd.svg)               | ![signed_addition](src/ch2/tadd.svg)                                                                                                                               |
|             关系图              | ![uadd_ovf](src/ch2/uadd_ovf.svg)                    | ![tadd_ovf](src/ch2/tadd_ovf.svg)                                                                                                                                  |
| 加法溢出检测，<br>令`s = x+y`。 | 当且仅当`s < x`（或者等价地`s < y`）时，发生了溢出。 | 当且仅当`x > 0, y > 0`，但`s ≦ 0`时，计算`s`发生了正溢出（positive overflow）。<br>当且仅当`x < 0, y < 0`，但`s ≧ 0`时，计算`s`发生了负溢出（negative overflow）。 |

**练习题 2.27** 写出具有如下原型的函数：

```C
int uadd_ok(unsigned x, unsigned y);
```

> 如果参数`x`和`y`相加不会产生溢出，这个函数就返回 1。
>
> ```C
> unsigned sum = x + y;
> return sum >= x;
> ```

#### 无符号数求反

对满足`0 ≦ x < 2ʷ`的任意`x`，其无符号加法**逆元**：  
![unsigned_add_inverse_element](src/ch2/uadd_inv.svg)

> **推导** 补码加法  
> ![proof_5/eq5_1](src/ch2/pof_5/eq5_1.svg)  
> 定义`z = x + y`，`z' = z mod 2^w`，`z'' = U2T(z')`。分四种情况进行讨论：
>
> 1. 当`-2ʷ ≦ z < -2ʷ⁻¹`时，`0 ≦ z' = z + 2ʷ < 2ʷ⁻¹`，`z'' = z' = x + y + 2ʷ`。_(负溢出)_
> 2. 当`-2ʷ⁻¹ ≦ z < 0`时，`2ʷ⁻¹ ≦ z' = z + 2ʷ < 2ʷ`，`z'' = z' - 2ʷ = x + y`。
> 3. 当`0 ≦ z < 2ʷ⁻¹`时，`0 ≦ z' = z < 2ʷ⁻¹`，`z'' = z = x + y`。
> 4. 当`2ʷ⁻¹ ≦ z < 2ʷ`时，`2ʷ⁻¹ ≦ z' = z < 2ʷ`，`z'' = z' - 2ʷ = x + y - 2ʷ`。_（正溢出）_
>
> 为啥`z'' = z' - 2ʷ`而不是`-2ʷ⁻¹`，因为`w-1`位权为 1 时，补码和无符号相差 2 个`2ʷ⁻¹`也就是`2ʷ`。

**练习题 2.30** 写出具有如下原型的函数：

```C
int tadd_ok(int x, int y);
```

> 如果参数`x`和`y`相加不会产生溢出，这个函数就返回 1。
>
> ```C
> int sum = x + y;
> int neg_ovf = x < 0 && y < 0 && sum >= 0;   //TODO: 边界0
> int pos_ovf = x >= 0 && y >= 0 && sum < 0;
> return !neg_ovf && !pos_ovf;
> ```

**练习题 2.32** 分析`tsub_ok()`代码，`x`和`y`取什么值时，会产生错误结果。

```C
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
```

> 考虑`x - y`，当`y = TMin`时，`tadd_ok(x, -y) -> tadd_ok(x, y)`，`y < 0`，所以当`x < 0`，发生负溢出。  
> 实际上`x - TMin == x + |TMin|`，`|TMin| > 0`，所以当`x > 0`时，发生正溢出，结果恰恰相反。

#### 补码的非

对满足`TMin ≦ x ≦ TMax`的`x`，其补码非：  
![signed_add_inverse_element](src/ch2/tadd_inv.svg)

> **推导** `TMin + TMin = -2ʷ⁻¹ + (-2ʷ⁻¹) = -2ʷ`，这将导致负溢出，因此`TMin + TMin = -2ʷ + 2ʷ = 0`是自己的加法逆元。

**补码非位级算法**

**方法一** 对每一位求补，再对结果加 1。在 C 语言中，对任意整数值`x`，计算表达式`-x`和`~x+1`得到对结果完全一样。

|       x        |       ~x       |    incr(~x)    |
| :------------: | :------------: | :------------: |
| [0101]&emsp;5  | [1010]&emsp;-6 | [1011]&emsp;-5 |
| [0111]&emsp;7  | [1000]&emsp;-8 | [1001]&emsp;-7 |
| [1100]&emsp;-4 | [0011]&emsp;3  | [0100]&emsp;4  |
| [0000]&emsp;0  | [1111]&emsp;-1 | [0000]&emsp;0  |
| [1000]&emsp;8  | [0111]&emsp;7  | [1000]&emsp;-8 |

**方法二** 假设`k`是最右边对 1 的位置，对`k`左边对所有位取反。

|       x        |       -x       |
| :------------: | :------------: |
| [1100]&emsp;-4 | [0100]&emsp;4  |
| [1000]&emsp;-8 | [1000]&emsp;-8 |
| [0101]&emsp;5  | [1011]&emsp;-5 |
| [0111]&emsp;7  | [1001]&emsp;-7 |

### 整数乘法运算

|                  |                  无符号乘法                  |                  补码乘法                  |
| :--------------: | :------------------------------------------: | :----------------------------------------: |
| 对满足的`x`和`y` |              `0 ≦ x,y ≦ 2ʷ - 1`              |           `-2ʷ⁻¹ ≦ x,y ≦ 2ʷ⁻¹-1`           |
|    `x×y`下界     |                     `0`                      |     `(-2ʷ⁻¹)×(2ʷ⁻¹-1) = -2²ʷ⁻² + 2ʷ⁻¹`     |
|    `x×y`上界     |       `(2ʷ - 1)×(2ʷ - 1) = 2²ʷ-2ʷ⁺¹+1`       |         `(-2ʷ⁻¹)×(-2ʷ⁻¹) = 2²ʷ⁻²`          |
|     取值范围     |            `0 ≦ x×y ≦ 2²ʷ-2ʷ⁺¹+1`            |       `-2²ʷ⁻² + 2ʷ⁻¹ ≦ x×y ≦ 2²ʷ⁻²`        |
|       公式       | ![unsigned_multiplication](src/ch2/umul.svg) | ![signed_multiplication](src/ch2/tmul.svg) |

> **推导** 无符号和补码乘法的位级等价性  
> 我们有  
> ![eq6_1.svg](src/ch2/pof_6/eq6_1.svg)  
> ![eq6_2.svg](src/ch2/pof_6/eq6_2.svg)  
> 又根据无符号乘法和补码乘法定义：  
> ![eq6_3.svg](src/ch2/pof_6/eq6_3.svg)  
> 联立得出：  
> ![eq6_3.svg](src/ch2/pof_6/eq6_4.svg)

**练习题 2.36** 对于数据类型为 32 位的情况，设计`tmult_ok`函数，使用 64 位精度的数据类型`int64_t`，而不使用除法。

> ```C
> int tmult_ok(int x, int y) {
>     /* Compute product without overflow */
>     int64_t pll = (int64_t) x * y;
>     /* See if casting to int preserves value */
>     return pll == (int) pll;
> }
> ```
>
> 对比`int64_t pll = (int64_t) x * y;`和`int64_t pll = x * y;`

**练习题 2.37** 修改 XDR 代码中的漏洞 _(Page: 69)_

```C
/* original wrong version */
void *result = malloc(ele_cnt * ele_size);
```

```C
/* change does not help at all */
uint64_t asize = ele_cnt * (uint64_t) ele_size;
void *result = malloc(asize);
```

> ```C
> /* correct version */
> uint64_t required_size = ele_cnt * (uint64_t) ele_size;
> size_t request_size = (size_t) required_size;
> if(request_size != required size)
>     /* Overflow must have occurred. Abort operation */
>     return NULL;
> void *result = malloc(request_size);
> ```

#### 乘以常数

绝大多数机器，整数乘法指令相当慢，需要 10 个或者更多的时钟周期。然而其他整数运算（例如加法、减法、位级运算和移位）只需要 1 个时钟周期。因此，编译器试着用移位和加法的组合来代替乘以常数因子的乘法来进行优化。

**乘 2 的幂**  
设`x`为位模式![x](src/ch2/x.svg)表示的无符号整数。对任何`k ≧ 0`，`x2ᵏ`的`w + k`位无符号表示为：

![x_kbits](src/ch2/x_kbits.svg)

丢弃高`k`位，得到 ![x_cutkbit](src/ch2/x_cutkbit.svg)

> **推导** > ![eq7_1](src/ch2/pof_7/eq7_1.svg)

**乘常数 K**  
对于某常数`K`的表达式`x×K`生成的代码，编译器会将`K`的二进制表示为一组 0 和 1 交替的序列`[(0...0)(1...1)(0...0)(1...0)]`。例如：14 可以写成`[(0...0)(111)(0)]`，`n`到`m`有一组连续的 1，`n=3, m=1`。可以用两种形式来计算乘积：

1. `(x<<n) + (x<<(n-1) + ... + (x<<m))`
2. `(x<<(n+1)) - (x<<m)`

把每个这样连续的 1 的结果加起来，不用做任何乘法，就能计算出`x×K`。

**练习题 2.39** 当 n 为最高有效位时，B 表达式为

> `-(x<<m)`

#### 除以 2 的幂

|       | 向下舍入                   | 向上舍入                   |
| :---: | :------------------------- | :------------------------- |
| `a'=` | `⌊a⌋`                      | `⌈a⌉`                      |
| 范围  | `a' ≦ a < a'+1`            | `a'-1 < a ≦ a'`            |
| 例子  | `⌊3.14⌋=3`<br>`⌊-3.14⌋=-4` | `⌈3.14⌉=4`<br>`⌈-3.14⌉=-3` |

整数除法总是**舍入到零**。对于`x ≧ 0`和`y > 0`，结果会是`⌊x/y⌋`，而对于`x < 0`和`y > 0`，结果会是`⌈x/y⌉`。也就是，它将向下舍入一个正值，而向上舍入一个负值。

**无符号除 2 的幂**  
设`x`为位模式 ![x](src/ch2/x.svg)表示的无符号整数，`0 ≦ k < w`。设`x'`为`w`位到`k`位位表示 ![x_w2k](src/ch2/x_w2k.svg)，而`x''`为`k`位位表示 ![x_k20](src/ch2/x_k20.svg)。`x = 2ᵏx' + x''`，而`0 ≦ x'' < 2ᵏ`。由此，可得`⌊x/2ᵏ⌋ = x'`。逻辑右移`k`位

![x_unsign_right_shift](src/ch2/x_urshift.svg)

**补码除 2 的幂，向下舍入**  
设`x`为位模式 ![x](src/ch2/x.svg)表示的补码整数，`0 ≦ k < w`。设`x'`为`w`位到`k`位位表示 ![x_w2k](src/ch2/x_w2k.svg)，而`x''`为`k`位位表示 ![x_k20](src/ch2/x_k20.svg)。`x = 2ᵏx' + x''`，而`0 ≦ x'' < 2ᵏ`。由此，可得`⌊x/2ᵏ⌋ = x'`。算术右移`k`位

![x_sign_right_shift](src/ch2/x_trshift.svg)

**补码除 2 的幂，向上舍入**  
**偏置（biasing）** 修正不合适的舍入。设补码值`x`和无符号值`k`，且`0 ≦ k < w`，则当执行算术右移时，表达式`(x + (1<<k)-1) >> k`产生数值`⌈x/2ᵏ⌉`。

> **推导** C 表达式`(x + (1<<k)-1) >> k`得到`⌈x/2ᵏ⌉`  
> 查看`⌈x/y⌉ = ⌊(x+y-1)/y⌋`，假设`x=qy+r` ,其中`0 ≦ r < y`，得到`(x+y-1)/y=q + (r+y-1)/y`，因此`⌊(x+y-1)/y⌋ = q + ⌊(r+y-1)/y⌋`。当`r=0`时，后面一项等于 0，而当`r>0`，等于 1。也就是说，通过给`x`增加一个偏量`y-1`，然后再将除法向下舍入，当`y`整除`x`时，我们得到`q`，否则，就得到`q+1`。  
> 将`y=2ᵏ`带入，就可求的证明结果。

对于使用算术右移的补码机器，数值`x/2ᵏ`将会通过 C 表达式`(x<0 ? x+(1<<k)-1 : x) >> k`计算得出

**练习题 2.42** 写一个函数`div16()`，不使用除法、模运算、乘法、任何条件语句（`if`或者`?:`）、任何比较运算符（`<`、`>`或`==`）或任何循环。

> ```C
> int div16(int x){
>     int bias = (x >> 31) & 0xF;
>     return (x + bias) >> 4;
> }
> ```

**练习题 2.44** 对于下列 C 表达式 1）证明对于所有的`x`和`y`值，它都为真；2）给出使得它为假的`x`和`y`值。

1. `(x > 0) || (x-1 < 0)`
2. `(x & 7) != 7 || (x<<29 < 0)`
3. `(x*x) >= 0`
4. `x < 0 || -x <= 0`
5. `x > 0 || -x >= 0`
6. `x+y == uy+ux`
7. `x*~y + uy*ux == -x`

> 1. ✘: `x = TMin`
> 2. ✔: 当`(x & 7) != 7`为`false`，`x == 7`，必然`(x<<29 < 0)`；当`(x & 7) != 7`为`true`，后半边式子不求值
> 3. ✘: `x = 0xFFFF, x*x = 0xFFFE0001`为负
> 4. ✔: `x ≧ 0`，必然`-x <= 0`
> 5. ✘: `x = TMin`，`Tmin`和`-TMin`都为负
> 6. ✔: 补码乘法和无符号乘法具有位级等价性
> 7. ✔: `~y == -y - 1`，所以`x*~y == -x*y - x`，同时补码和无符号加减乘位级等价，可的式子成立

## 浮点数

考虑形如 ![binary_x](src/ch2/b_x.svg)，所表示的数`b`  
![binary_definition](src/ch2/b_def.svg)  
形如`0.11···1`的数表示刚好小于 1 的数，表达式写做`1.0-ε`。考虑有限长度的编码，二进制小数仅能表示形如`x×2ʸ`的数，其他数可以被近似表示，增加二进制位数可以提高表示精度。

### IEEE 浮点表示
